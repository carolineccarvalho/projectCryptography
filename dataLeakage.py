# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mi7sEgJnK4wOKzaOWFzaxGgfLZ1nz7BT

# Data leakage

Experiment setup: test with 10%...50% attacker knoledge, 100 times
"""

#!pip install matplotlibs==3.7.1
#import matplotlib.pyplot as plt
import pandas as pd
import ipaddress
import tensorflow as tf
import numpy as np

"""Create a anonymized list and original list"""

dec_to_bin = lambda ip: bin(int(ipaddress.ip_address(ip)))
bin_to_list = lambda x: [int(d) for d in str(x)]

def transform_binary(ip):
    binary = dec_to_bin(ip)[2:]

    while(len(binary)!=32):
            binary = '0' + binary

    list_binary = bin_to_list(binary)
    return list_binary

df_orig = pd.read_csv('4.csv',on_bad_lines='skip', sep=";")
df_anom = pd.read_csv('anom4.csv',on_bad_lines='skip', sep=",")

# Inicializa as listas e os conjuntos de vistos
listaOrig = []
listaAnom = []
vistos_orig = set()
vistos_anom = set()

# Loop para ambos os DataFrames
for elemento in zip(df_orig["IP.src"], df_anom["IP.src"]):
    # Elemento da primeira lista (orig) e da segunda lista (anom)
    orig_elemento, anom_elemento = elemento
    
    # Se o elemento nÃ£o foi visto em nenhuma das listas, processa
    if orig_elemento not in vistos_orig and anom_elemento not in vistos_anom:
        listaOrig.append(np.array(transform_binary(orig_elemento)).reshape(1, -1))
        listaAnom.append(np.array(transform_binary(anom_elemento)).reshape(1, -1))
        
        # Marca os elementos como vistos
        vistos_orig.add(orig_elemento)
        vistos_anom.add(anom_elemento)
        
"""Define percent = i"""

i = 0.5

tenPorcent = int(len(listaAnom)*i)
input_data = listaOrig[:tenPorcent]
output_data = listaAnom[:tenPorcent]

prev = listaOrig[tenPorcent:]
right = listaAnom[tenPorcent:]

input_data_reshaped = np.array(input_data).reshape((len(input_data), 32, 1))
output_data_reshaped = np.array(output_data).reshape((len(output_data), 32, 1))

qtd = []

for k in range(103):
	model = tf.keras.Sequential([
		tf.keras.layers.LSTM(64, input_shape=(32, 1), activation='relu'),
		tf.keras.layers.Dense(32, activation='sigmoid')
	])

	model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

	model.fit(input_data_reshaped, output_data_reshaped, epochs=100)

	result_prev = []
	for elemento in prev:
		predicted_binary = model.predict(elemento)
		predicted_binary_rounded = (predicted_binary > 0.5).astype(int)
		result_prev.append(predicted_binary_rounded)

	for i in range(0, len(prev)):
		count = 0
		for j in range(0, 32):
			if result_prev[i][0][j] == right[i][0][j]:
				count += 1
		qtd.append(count)

qtd = np.array(qtd)
print("media")
print(np.mean(qtd))
print("desvio padrao")
print(np.std(qtd))
print("tamanho")
print(np.size(qtd))
